@page "/oninput-validation"
@using WebDevelopment.Shared.DTO
@using WebDevelopment.Shared.Enums
@using WebDevelopment.Shared.Interfaces
@inject ICountryService CountryService
@inject IJSRuntime JSRuntime


<div>
    <span style="font-size:30px; font-weight:bold;">Instant onInput JS counter and validator</span>
</div>
<input id="htmlEditor" @bind="@TestValue" autocomplete="off" />@*@oninput="e => {TestValue = e.Value?.ToString();}*@
               
<div>
    Left characters: @(CharactersLeft > 0 ? CharactersLeft : 0)
</div>

<span class="text-danger fs-13" style="font-size: 10px;">
    @(string.IsNullOrEmpty(StringLimitError) ? "" : StringLimitError)
</span>



<div>
    <span style="font-size:30px; font-weight:bold;">Csharp Blazor instant counter and validator</span>
</div>


<div>
    <span style="font-size:15px; font-weight:bold;">@((MarkupString)("input type=\"text\" @bind-value\"TestValue1\" @bind-value:event=\"oninput\""))</span>
</div>
<input type="text" @bind-value="TestValue1" @bind-value:event="oninput" />
<p>  Left characters: @CharactersLeft1</p>
<span class="text-danger fs-13" style="font-size: 10px;">
    @(string.IsNullOrEmpty(StringLimitError1) ? "" : StringLimitError1)
</span>


<div>
    <span style="font-size:15px; font-weight:bold;">@((MarkupString)("input type=\"text\" @bind-value=\"TestValue1\" @oninput=\"OnTextChanged\""))</span>
</div>

<input type="text" @bind-value="TestValue2" @oninput="OnTextChanged" />
<p>  Left characters: @CharactersLeft2</p>
<span class="text-danger fs-13" style="font-size: 10px;">
    @(string.IsNullOrEmpty(StringLimitError2) ? "" : StringLimitError2)
</span>

@code {
    private string TestValue { get; set; } = string.Empty;

    private string _testValue1 = string.Empty; 
    private string TestValue1 
    { 
        get => _testValue1; 
        set
        {
            _testValue1 = value;
            StringLimitError1 = GetStringLimitError(TestValue1.Length);
        }

    }
    private string TestValue2 { get; set; } = string.Empty;

    private int CharactersLeft { get; set; } = TextMaxLen;
    private int CharactersLeft1 => TextMaxLen - (TestValue1?.Length ?? 0);
    private int CharactersLeft2 => TextMaxLen - (TestValue2?.Length ?? 0);

    private string StringLimitError { get; set; } = string.Empty;
    private string StringLimitError1 { get; set; } = string.Empty;
    private string StringLimitError2 { get; set; } = string.Empty;

    private const int TextMinLen = 10;
    private const int TextMaxLen = 30;

    private DotNetObjectReference<InstantStringCountAndValidation>? _objRef;


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("editorCounterValidator", TextMaxLen, _objRef);
        }
    }

    [JSInvokable]
    public void ChangeLimitError(int textLength, int leftLength)
    {
        CharactersLeft = leftLength;
        Console.WriteLine($"textLength {textLength}");
        StringLimitError = GetStringLimitError(textLength);
        StateHasChanged();
    }

    public string GetStringLimitError(int textLength)
    {
        switch (textLength)
        {
            case < 1:
                return $"Minimum limit is {TextMinLen}";
            case < TextMinLen and >= 1:
                return $"Minimum limit is {TextMinLen}";
            case >= TextMinLen and < TextMaxLen:
                return "";
            case >= TextMaxLen:
                return $"Maximum limit of {TextMaxLen} is reached";
        }
    }        


    private void OnTextChanged(ChangeEventArgs e)
    {
        Console.WriteLine($"OnTextChanged - {e.Value.ToString()}");
        StringLimitError2 = GetStringLimitError(e.Value.ToString().Length);
        TestValue2 = e.Value?.ToString() ?? "";
    }

    // private void MakeChange()
    // {
    //     if(TestValue.Count() > 10)
    //     {
    //         TestValue = TestValue.Substring(0, 9);
    //         StringLimitError = "Eror string length";
    //         StateHasChanged();
    //     }
    //     else
    //     {
    //         StringLimitError = string.Empty;
    //     }
    // }
}